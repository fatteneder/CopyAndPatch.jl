import Artifacts
import Clang_jll
import Downloads
import Libffi_jll
import LLVM_jll
import Preferences
import Scratch
import TOML

nthreads = Sys.CPU_THREADS รท 2

project_file = joinpath(@__DIR__, "..", "Project.toml")
manifest_file = joinpath(@__DIR__, "..", "Manifest.toml")

project_toml = TOML.parsefile(project_file)
uuid = Base.UUID(project_toml["uuid"])
version = VersionNumber(project_toml["version"])
isdeved = haskey(only(TOML.parsefile(manifest_file)["deps"]["CopyAndPatch"]), "path")

scratch_dir = Scratch.get_scratch!(uuid, "CopyAndPatch-$(version)")
stencil_dir = joinpath(@__DIR__, "..", "stencils")
vendored_julia_dir = joinpath(Sys.BINDIR, "..")
julia_repo_artifact_dir = Artifacts.artifact"julia_repo"
bin_dir = joinpath(scratch_dir, "cpjit-bin", "")

# copy the julia_repo dir into a scratch dir, as we need to download some dependencies in there too
julia_repo_dir = joinpath(scratch_dir, "julia_repo")
mkpath(julia_repo_dir)
if isempty(readdir(julia_repo_dir))
    cp(julia_repo_artifact_dir, julia_repo_dir, force=true)
    julia_repo_dir = joinpath(julia_repo_dir, only(readdir(julia_repo_dir)))
    # install julia's dependencies, needed to be able to include julia_internal.h in stencils
    run(Cmd(`make -C $(julia_repo_dir)/deps -j$(nthreads)`))
else
    julia_repo_dir = joinpath(julia_repo_dir, only(readdir(julia_repo_dir)))
end

# extract LD_LIBRARY list needed for clang cmd
clang_cmd = Clang_jll.clang()
idx = findfirst(clang_cmd.env) do e
    startswith(e, "LD_LIBRARY_PATH=")
end |> something
ld_library_path = split(clang_cmd.env[idx], "=")[2]

# env variables needed for make file
make_env = Dict()
make_env["JULIA_REPO_SRC"] = joinpath(julia_repo_dir, "src")
make_env["JULIA_INCLUDE"] = joinpath(vendored_julia_dir, "include")
make_env["JULIA_LIB"] = joinpath(vendored_julia_dir, "lib")
make_env["LIBFFI_INCLUDE"] = joinpath(Libffi_jll.artifact_dir, "include")
make_env["READOBJ"] = joinpath(LLVM_jll.artifact_dir, "tools", "llvm-readobj")
make_env["OBJDUMP"] = joinpath(LLVM_jll.artifact_dir, "tools", "llvm-objdump")
make_env["CLANG"] = joinpath(Clang_jll.clang_path)
make_env["LD_LIBRARY_PATH"] = ld_library_path
make_env["BINDIR"] = bin_dir
# Makefile options
make_env["MAKE_DEBUG"] = Preferences.load_preference(uuid, "debug", 0)
make_env["MAKE_USE_GHC_CC"] = Preferences.load_preference(uuid, "use_ghc_cc", 0)
make_env["MAKE_EMIT_LLVM"] = Preferences.load_preference(uuid, "emit_llvm",  0)


# merge with current env
env = copy(ENV)
for (k,v) in pairs(make_env)
    if k == "LD_LIBRARY_PATH"
        env[k] = "$(get!(env, k, "")):$(v)"
    else
        env[k] = string(v)
    end
end


if isdeved
    # store the make variables in a local shell script to allow building stencils manually
    # with `cd stencils; source setup.sh; make`
    open(joinpath(@__DIR__, "..", "stencils", "setup.sh"), write=true) do f
        println(f, "#!/usr/bin/env bash")
        println(f, "# this file was autogenerated by Pkg.build(\"CopyAndPatch\") for a deved version of CopyAndPatch.jl ($(@__FILE__))")
        println(f, "export CPJIT_SCRATCH_DIR=\"$scratch_dir\"")
        println(f, "export CPJIT_VENDORED_JULIA_DIR=\"$vendored_julia_dir\"")
        println(f, "export CPJIT_JULIA_REPO_ARTIFACT_DIR=\"$julia_repo_artifact_dir\"")
        for (k,v) in pairs(make_env)
            println(f, "export $k=\"$v\"")
        end
    end
end

# The pkg needs the llvm-mc artifact. To avoid loading LLVM_jll, we symlink it into the scratch dir.
llvm_mc = joinpath(LLVM_jll.artifact_dir, "tools", "llvm-mc")
sym_llvm_mc = joinpath(scratch_dir, "llvm-mc")
if !islink(sym_llvm_mc)
    symlink(llvm_mc, sym_llvm_mc)
end

# compile our stencils
run(Cmd(`make -C $(stencil_dir) -j$(nthreads)`; env))
